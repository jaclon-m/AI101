1. 浅拷贝和深拷贝
    浅拷贝
        拷贝父对象，不会拷贝对象的内部的子对象。拷贝后只有第一层是独立的。
        切片操作（如 [:]）。
        使用工厂函数（如 list() / set()）。
        使用 copy 模块的 copy() 函数。
    深拷贝
        完全拷贝了父对象及其子对象。拷贝后所有层都是独立的。
        copy.deepcopy()
2.迭代器
    遍历
        一般是指将容器中的元素一个个拿出来
    循环
        程序流程控制的一种方式
        用于重复的执行一段代码
        通过循环实现遍历
    迭代
        也是实现遍历的一种方式

    迭代器有两个基本的方法：iter() 和 next()
        iter:创建一个迭代器对象
        next:取出一个元素

    在容器对象上使用 for 语句时，在幕后，for 语句会在容器对象上调用 iter()。
    通过next方法遍历数据，next方法底层调用的是__next__方法，此方法将逐一访问容器中的元素。
    当元素用尽时，__next__() 将引发 StopIteration 异常来通知终止 for 循环。

3.生成器
    生成器函数的优势是它们可以按需生成值，避免一次性生成大量数据并占用大量内存
    返回数据时会使用 yield 语句
    当在生成器函数中使用yield语句时，函数的执行将会暂停，并将 yield 后的表达式作为当前迭代的值返回。

    可以通过send方法，向生成器发送数据

4.命名空间
    内建命名空间
    全局命名空间
    函数命名空间
    类命名空间
    实例命名空间
    ....
5.作用域
    局部 Local -> 嵌套 (Enclosing) ->全局 Global ->内建 Built-in
        LEGB
6.闭包
    需要满足的条件：
        在函数内部嵌套定义了其它函数
        内层函数访问了外层函数的局部变量
        外层函数的返回值为内层函数对象
    优势： 底层将外层函数局部变量的生命周期延长，供内部函数使用

7.装饰器
    装饰器允许在不修改原有函数代码的基础上，动态地增加或修改函数的功能。
    装饰器本质上是一个接收函数作为输入并返回一个新的包装过后的函数的对象。

    语法：通过函数创建装饰器，底层就是闭包
        def decorator(func):
            def inner(参数):
                # 添加功能
                func(参数)
                # 添加功能
            return inner
    @装饰函数的名   ---装饰器语法糖
        会自动将被装饰函数对象作为参数传递给装饰函数，然后将返回的 inner 函数替换掉原来的被装饰函数。

    多层装饰器的装饰过程
        多个装饰器的装饰过程：离函数最近的装饰器先装饰，然后外面的装饰器再进行装饰

    带参数与的装饰器
        @times(2) === > times(2)(func)

    类装饰器
        定义类
            接收一个函数作为实例变量
            重写__call__方法进行装饰，将经过装饰后的函数执行结果作为返回值返回

        @类名
        函数    ===>会进行类的实例化过程，创建新的对象，在创建对象的过程中，会将函数本身传递给init方法。
        函数执行的时候，相当于调用对象底层调用__call__方法



